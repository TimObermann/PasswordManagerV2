package passwordmanager.crypt;


import passwordmanager.crypt.cipher.aes.AES;
import passwordmanager.crypt.cipher.aes.AES_MODE;
import passwordmanager.crypt.cipher.aes.AES_SIZE;
import passwordmanager.crypt.cipher.chacha.ChaCha;
import passwordmanager.crypt.cipher.chacha.ChaCha20_Poly1305;
import passwordmanager.crypt.cipher.chacha.XChaCha;
import passwordmanager.crypt.cipher.chacha.XChaCha20_Poly1305;
import passwordmanager.crypt.hash.Blake2b;
import passwordmanager.crypt.mac.HMAC;
import passwordmanager.crypt.hash.SHA2;
import passwordmanager.crypt.kdf.argon2.ARGON2_TYPE;
import passwordmanager.crypt.kdf.argon2.Argon2;
import passwordmanager.crypt.kdf.PBKDF2;
import passwordmanager.crypt.kdf.scrypt.Scrypt;
import passwordmanager.crypt.mac.Poly1305;

public class TestCases {

    public static void main(String[] args) {
        run_chacha_test();
    }

    private static void run_Xchacha_poly_test() {
        XChaCha20_Poly1305 chaChaPoly = new XChaCha20_Poly1305();

        byte[] plaintext = new byte[] {
                0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74, 0x6c,
                0x65, 0x6d, 0x65, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x61, 0x73,
                0x73, 0x20, 0x6f, 0x66, 0x20, 0x27, 0x39, 0x39, 0x3a, 0x20, 0x49, 0x66, 0x20, 0x49, 0x20, 0x63,
                0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6f,
                0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x74, 0x69, 0x70, 0x20, 0x66, 0x6f, 0x72, 0x20,
                0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x2c, 0x20, 0x73, 0x75, 0x6e, 0x73,
                0x63, 0x72, 0x65, 0x65, 0x6e, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x69,
                0x74, 0x2e
        };

        byte[] aad = new byte[] {
                (byte) 0x50, (byte) 0x51, (byte) 0x52, (byte) 0x53,
                (byte) 0xc0, (byte) 0xc1, (byte) 0xc2, (byte) 0xc3,
                (byte) 0xc4, (byte) 0xc5, (byte) 0xc6, (byte) 0xc7
        };

        int[] key = new int[] {
                0x83828180, 0x87868584, 0x8b8a8988, 0x8f8e8d8c,
                0x93929190, 0x97969594, 0x9b9a9998, 0x9f9e9d9c
        };

        int[] nonce = {
                0x43424140,
                0x47464544,
                0x4B4A4948,
                0x4F4E4D4C,
                0x53525150,
                0x57565554
        };

        System.out.println(bytesToHexString(chaChaPoly.encrypt(plaintext, key, nonce, aad)));

    }
    private static void run_Xchacha_test() {
        XChaCha chaCha = new XChaCha(20);

        byte[] plaintext = {
                0x54, 0x68, 0x65, 0x20, 0x64, 0x68, 0x6f, 0x6c, 0x65, 0x20, 0x28, 0x70, 0x72, 0x6f, 0x6e, 0x6f,
                0x75, 0x6e, 0x63, 0x65, 0x64, 0x20, 0x22, 0x64, 0x6f, 0x6c, 0x65, 0x22, 0x29, 0x20, 0x69, 0x73,
                0x20, 0x61, 0x6c, 0x73, 0x6f, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x20, 0x61, 0x73, 0x20, 0x74,
                0x68, 0x65, 0x20, 0x41, 0x73, 0x69, 0x61, 0x74, 0x69, 0x63, 0x20, 0x77, 0x69, 0x6c, 0x64, 0x20,
                0x64, 0x6f, 0x67, 0x2c, 0x20, 0x72, 0x65, 0x64, 0x20, 0x64, 0x6f, 0x67, 0x2c, 0x20, 0x61, 0x6e,
                0x64, 0x20, 0x77, 0x68, 0x69, 0x73, 0x74, 0x6c, 0x69, 0x6e, 0x67, 0x20, 0x64, 0x6f, 0x67, 0x2e,
                0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65,
                0x20, 0x73, 0x69, 0x7a, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x47, 0x65, 0x72, 0x6d, 0x61,
                0x6e, 0x20, 0x73, 0x68, 0x65, 0x70, 0x68, 0x65, 0x72, 0x64, 0x20, 0x62, 0x75, 0x74, 0x20, 0x6c,
                0x6f, 0x6f, 0x6b, 0x73, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x20, 0x6c, 0x69, 0x6b, 0x65, 0x20, 0x61,
                0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x2d, 0x6c, 0x65, 0x67, 0x67, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x78,
                0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x68, 0x69, 0x67, 0x68, 0x6c, 0x79, 0x20, 0x65, 0x6c,
                0x75, 0x73, 0x69, 0x76, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x73, 0x6b, 0x69, 0x6c, 0x6c, 0x65,
                0x64, 0x20, 0x6a, 0x75, 0x6d, 0x70, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x63, 0x6c, 0x61, 0x73,
                0x73, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x77, 0x6f, 0x6c, 0x76,
                0x65, 0x73, 0x2c, 0x20, 0x63, 0x6f, 0x79, 0x6f, 0x74, 0x65, 0x73, 0x2c, 0x20, 0x6a, 0x61, 0x63,
                0x6b, 0x61, 0x6c, 0x73, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x66, 0x6f, 0x78, 0x65, 0x73, 0x20,
                0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x78, 0x6f, 0x6e, 0x6f, 0x6d, 0x69, 0x63,
                0x20, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x20, 0x43, 0x61, 0x6e, 0x69, 0x64, 0x61, 0x65, 0x2e
        };

        int[] key = new int[] {
                0x83828180, 0x87868584, 0x8b8a8988, 0x8f8e8d8c,
                0x93929190, 0x97969594, 0x9b9a9998, 0x9f9e9d9c
        };

        int[] nonce = {
                0x43424140,
                0x47464544,
                0x4B4A4948,
                0x4F4E4D4C,
                0x53525150,
                0x57565554
        };

        int[] Hnonce = {
                0x09000000,
                0x4A000000,
                0x00000000,
                0x27594131
        };
        int[] Hkey = {
                0x03020100,
                0x07060504,
                0x0b0a0908,
                0x0f0e0d0c,
                0x13121110,
                0x17161514,
                0x1b1a1918,
                0x1f1e1d1c
        };

        //byte[] out = new byte[32];
        //ints_to_bytes(chaCha.HChaCha(Hkey, Hnonce), out);

        //System.out.println(bytesToHexString(out));

        System.out.println(bytesToHexString(chaCha.encrypt(plaintext, key, 1, nonce)));
    }
    private static void run_chacha_poly_test() {
        ChaCha20_Poly1305 chaCha_poly = new ChaCha20_Poly1305();
        ChaCha chaCha = new ChaCha(20);
        Poly1305 poly = new Poly1305();

        byte[] plaintext = new byte[] {
                0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74, 0x6c,
                0x65, 0x6d, 0x65, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x61, 0x73,
                0x73, 0x20, 0x6f, 0x66, 0x20, 0x27, 0x39, 0x39, 0x3a, 0x20, 0x49, 0x66, 0x20, 0x49, 0x20, 0x63,
                0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6f,
                0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x74, 0x69, 0x70, 0x20, 0x66, 0x6f, 0x72, 0x20,
                0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x2c, 0x20, 0x73, 0x75, 0x6e, 0x73,
                0x63, 0x72, 0x65, 0x65, 0x6e, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x69,
                0x74, 0x2e
        };

        byte[] aad = new byte[] {
                (byte) 0x50, (byte) 0x51, (byte) 0x52, (byte) 0x53,
                (byte) 0xc0, (byte) 0xc1, (byte) 0xc2, (byte) 0xc3,
                (byte) 0xc4, (byte) 0xc5, (byte) 0xc6, (byte) 0xc7
        };

        int[] key = new int[] {
                0x83828180, 0x87868584, 0x8b8a8988, 0x8f8e8d8c,
                0x93929190, 0x97969594, 0x9b9a9998, 0x9f9e9d9c
        };

        int[] nonce = new int[] {
                0x00000007, 0x43424140, 0x47464544
        };

        byte[] iv = new byte[]{
                0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47
        };

        byte[] secret_data = chaCha_poly.encrypt(plaintext, key, iv, 7, aad);
        System.out.println(bytesToHexString(secret_data));
        System.out.println(bytesToHexString(chaCha_poly.decrypt(secret_data, key, iv, 7, aad)));
    }
    private static void run_poly1305_test() {
        Poly1305 poly1305 = new Poly1305();

        byte[] key = new byte[] {
                (byte) 0x85, (byte) 0xd6, (byte) 0xbe, (byte) 0x78,
                (byte) 0x57, (byte) 0x55, (byte) 0x6d, (byte) 0x33,
                (byte) 0x7f, (byte) 0x44, (byte) 0x52, (byte) 0xfe,
                (byte) 0x42, (byte) 0xd5, (byte) 0x06, (byte) 0xa8,
                (byte) 0x01, (byte) 0x03, (byte) 0x80, (byte) 0x8a,
                (byte) 0xfb, (byte) 0x0d, (byte) 0xb2, (byte) 0xfd,
                (byte) 0x4a, (byte) 0xbf, (byte) 0xf6, (byte) 0xaf,
                (byte) 0x41, (byte) 0x49, (byte) 0xf5, (byte) 0x1b
        };

        byte[] message = new byte[] {
                (byte) 0x43, (byte) 0x72, (byte) 0x79, (byte) 0x70,
                (byte) 0x74, (byte) 0x6f, (byte) 0x67, (byte) 0x72,
                (byte) 0x61, (byte) 0x70, (byte) 0x68, (byte) 0x69,
                (byte) 0x63, (byte) 0x20, (byte) 0x46, (byte) 0x6f,
                (byte) 0x72, (byte) 0x75, (byte) 0x6d, (byte) 0x20,
                (byte) 0x52, (byte) 0x65, (byte) 0x73, (byte) 0x65,
                (byte) 0x61, (byte) 0x72, (byte) 0x63, (byte) 0x68,
                (byte) 0x20, (byte) 0x47, (byte) 0x72, (byte) 0x6f,
                (byte) 0x75, (byte) 0x70
        };

        System.out.println(bytesToHexString(poly1305.poly1305_mac(message, key)));
    }
    private static void run_chacha_test() {
        ChaCha chaCha = new ChaCha(20, 1);

        int[] key = new int[] {
                0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,
                0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c
        };

        int[] nonce = new int[] {
                0x00000000, 0x4a000000, 0x00000000
        };

        byte[] plaintext = new byte[] {
                0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74, 0x6c,
                0x65, 0x6d, 0x65, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x61, 0x73,
                0x73, 0x20, 0x6f, 0x66, 0x20, 0x27, 0x39, 0x39, 0x3a, 0x20, 0x49, 0x66, 0x20, 0x49, 0x20, 0x63,
                0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6f,
                0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x74, 0x69, 0x70, 0x20, 0x66, 0x6f, 0x72, 0x20,
                0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x2c, 0x20, 0x73, 0x75, 0x6e, 0x73,
                0x63, 0x72, 0x65, 0x65, 0x6e, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x69,
                0x74, 0x2e
        };

        //System.out.println(bytesToHexString(chaCha.chacha_encrypt(plaintext, key, 1, nonce)));
        byte[] ciphertext = chaCha.encrypt(plaintext, key, 1, nonce);
        //byte[] ciphertext = chaCha.chacha_encrypt("Hello ChaCha20! This is a longer Text so parallelization actually makes sense. Did you know that it's parall -E- lization and not parall -A- lization. I always assumed it would be spelled with an A. Oh well it is what it is!, WOW you really need A LOT of text for a significant amount of bytes. Nevertheless this I will persevere and not run out of ideas on what to ramble in this mini text document. Damn, already ran out. That sucks man. Whatever this should be enough. I'll check real quick!".getBytes(), key, 1, nonce);

        System.out.println(bytesToHexString(ciphertext));

        //System.out.println(bytesToHexString(chaCha.decrypt(ciphertext, key, 1, nonce)));
        //System.out.println(new String(chaCha.chacha_encrypt(ciphertext, key, 1, nonce)));
    }
    private static void run_scrypt_test() {
        Scrypt scrypt = new Scrypt();

        byte[] test_block = new byte[] {
                (byte)0xf7, (byte)0xce, (byte)0x0b, (byte)0x65, (byte)0x3d, (byte)0x2d, (byte)0x72, (byte)0xa4,
                (byte)0x10, (byte)0x8c, (byte)0xf5, (byte)0xab, (byte)0xe9, (byte)0x12, (byte)0xff, (byte)0xdd,
                (byte)0x77, (byte)0x76, (byte)0x16, (byte)0xdb, (byte)0xbb, (byte)0x27, (byte)0xa7, (byte)0x0e,
                (byte)0x82, (byte)0x04, (byte)0xf3, (byte)0xae, (byte)0x2d, (byte)0x0f, (byte)0x6f, (byte)0xad,
                (byte)0x89, (byte)0xf6, (byte)0x8f, (byte)0x48, (byte)0x11, (byte)0xd1, (byte)0xe8, (byte)0x7b,
                (byte)0xcc, (byte)0x3b, (byte)0xd7, (byte)0x40, (byte)0x0a, (byte)0x9f, (byte)0xfd, (byte)0x29,
                (byte)0x09, (byte)0x4f, (byte)0x01, (byte)0x84, (byte)0x63, (byte)0x95, (byte)0x74, (byte)0xf3,
                (byte)0x9a, (byte)0xe5, (byte)0xa1, (byte)0x31, (byte)0x52, (byte)0x17, (byte)0xbc, (byte)0xd7,
                (byte)0x89, (byte)0x49, (byte)0x91, (byte)0x44, (byte)0x72, (byte)0x13, (byte)0xbb, (byte)0x22,
                (byte)0x6c, (byte)0x25, (byte)0xb5, (byte)0x4d, (byte)0xa8, (byte)0x63, (byte)0x70, (byte)0xfb,
                (byte)0xcd, (byte)0x98, (byte)0x43, (byte)0x80, (byte)0x37, (byte)0x46, (byte)0x66, (byte)0xbb,
                (byte)0x8f, (byte)0xfc, (byte)0xb5, (byte)0xbf, (byte)0x40, (byte)0xc2, (byte)0x54, (byte)0xb0,
                (byte)0x67, (byte)0xd2, (byte)0x7c, (byte)0x51, (byte)0xce, (byte)0x4a, (byte)0xd5, (byte)0xfe,
                (byte)0xd8, (byte)0x29, (byte)0xc9, (byte)0x0b, (byte)0x50, (byte)0x5a, (byte)0x57, (byte)0x1b,
                (byte)0x7f, (byte)0x4d, (byte)0x1c, (byte)0xad, (byte)0x6a, (byte)0x52, (byte)0x3c, (byte)0xda,
                (byte)0x77, (byte)0x0e, (byte)0x67, (byte)0xbc, (byte)0xea, (byte)0xaf, (byte)0x7e, (byte)0x89
        };

        System.out.println(bytesToHexString(scrypt.scrypt("pleaseletmein".getBytes(), "SodiumChloride".getBytes(), 16384, 8, 1, 64)));
    }
    private static void run_PBKDF2_test() {
        PBKDF2 kdf = new PBKDF2();

        System.out.println(bytesToHexString(kdf.generate("Password".getBytes(), "NaCl".getBytes(), 600000, 64)));

    }
    private static void run_argon2_test() {
        Argon2 argon2 = new Argon2();

        byte[] password = new byte[32];
        byte[] salt = new byte[16];
        byte[] assocData = new byte[12];
        byte[] secret = new byte[8];

        for (int i = 0; i < password.length; i++) {
            password[i] = (byte) 0x01;
        }
        for (int i = 0; i < salt.length; i++) {
            salt[i] = (byte) 0x02;
        }
        for (int i = 0; i < secret.length; i++) {
            secret[i] = (byte) 0x03;
        }
        for (int i = 0; i < assocData.length; i++) {
            assocData[i] = (byte) 0x04;
        }

        System.out.println(bytesToHexString(argon2.argon2(password, salt, secret, assocData, 4, 32, 32, 3, 0x13, ARGON2_TYPE.ARGON2_d)));
    }
    private static void run_blake2b_test() {

        byte[] key = new byte[]{
                (byte)0x00, (byte)0x01, (byte)0x02, (byte)0x03,
                (byte)0x04, (byte)0x05, (byte)0x06, (byte)0x07,
                (byte)0x08, (byte)0x09, (byte)0x0A, (byte)0x0B,
                (byte)0x0C, (byte)0x0D, (byte)0x0E, (byte)0x0F,

                (byte)0x10, (byte)0x11, (byte)0x12, (byte)0x13,
                (byte)0x14, (byte)0x15, (byte)0x16, (byte)0x17,
                (byte)0x18, (byte)0x19, (byte)0x1A, (byte)0x1B,
                (byte)0x1C, (byte)0x1D, (byte)0x1E, (byte)0x1F,

                (byte)0x20, (byte)0x21, (byte)0x22, (byte)0x23,
                (byte)0x24, (byte)0x25, (byte)0x26, (byte)0x27,
                (byte)0x28, (byte)0x29, (byte)0x2A, (byte)0x2B,
                (byte)0x2C, (byte)0x2D, (byte)0x2E, (byte)0x2F,

                (byte)0x30, (byte)0x31, (byte)0x32, (byte)0x33,
                (byte)0x34, (byte)0x35, (byte)0x36, (byte)0x37,
                (byte)0x38, (byte)0x39, (byte)0x3A, (byte)0x3B,
                (byte)0x3C, (byte)0x3D, (byte)0x3E, (byte)0x3F
        };

        byte[] message = new byte[]{(byte)0x00, (byte)0x01, (byte)0x02, (byte)0x03,
                (byte)0x04, (byte)0x05, (byte)0x06, (byte)0x07,
                (byte)0x08, (byte)0x09, (byte)0x0A, (byte)0x0B,
                (byte)0x0C, (byte)0x0D, (byte)0x0E, (byte)0x0F,

                (byte)0x10, (byte)0x11, (byte)0x12, (byte)0x13,
                (byte)0x14, (byte)0x15, (byte)0x16, (byte)0x17,
                (byte)0x18, (byte)0x19, (byte)0x1A, (byte)0x1B,
                (byte)0x1C, (byte)0x1D, (byte)0x1E, (byte)0x1F,

                (byte)0x20, (byte)0x21, (byte)0x22, (byte)0x23,
                (byte)0x24, (byte)0x25, (byte)0x26, (byte)0x27,
                (byte)0x28, (byte)0x29, (byte)0x2A, (byte)0x2B,
                (byte)0x2C, (byte)0x2D, (byte)0x2E, (byte)0x2F,

                (byte)0x30, (byte)0x31, (byte)0x32, (byte)0x33,
                (byte)0x34, (byte)0x35, (byte)0x36, (byte)0x37,
                (byte)0x38, (byte)0x39, (byte)0x3A, (byte)0x3B,
                (byte)0x3C, (byte)0x3D, (byte)0x3E, (byte)0x3F,

                (byte) 0x40, (byte) 0x41, (byte) 0x42, (byte) 0x43
        };

        byte[] small_message = new byte[] {
                (byte) 0x00, (byte) 0x01
        };

        byte[] zero_key = new byte[0];

        byte[] long_message = new byte[255];
        for (int i = 0; i < 255; i++) {
            long_message[i] = (byte) i;
        }

        byte[] zero_message = new byte[0];

        Blake2b blake = new Blake2b(key, 64);

        blake.insert(zero_message);

        System.out.println(bytesToHexString(Blake2b.hash(key, zero_message, 64)));
        System.out.println(bytesToHexString(blake.generate()));
    }
    private static void run_HMAC_test() {
        HMAC hmac = new HMAC(new SHA2());

        byte[] key = new byte[] {
                (byte)0x0b, (byte)0x0b, (byte)0x0b, (byte)0x0b,
                (byte)0x0b, (byte)0x0b, (byte)0x0b, (byte)0x0b,
                (byte)0x0b, (byte)0x0b, (byte)0x0b, (byte)0x0b,
                (byte)0x0b, (byte)0x0b, (byte)0x0b, (byte)0x0b,
                (byte)0x0b, (byte)0x0b, (byte)0x0b, (byte)0x0b
        };

        byte[] long_key = new byte[20];
        for (int i = 0; i < long_key.length; i++) {
            long_key[i] = (byte) 0xAA;
        }

        byte[] long_message = new byte[50];
        for (int i = 0; i < long_message.length; i++) {
            long_message[i] = (byte) 0xDD;
        }

        System.out.println(bytesToHexString(hmac.generate("Hi There".getBytes(), key, 64)));
        System.out.println(bytesToHexString(hmac.generate("what do ya want for nothing?".getBytes(), "Jefe".getBytes(), 64)));
        System.out.println(bytesToHexString(hmac.generate(long_message, long_key, 64)));


    }
    private static void run_SHA_test(){
        SHA2 sha = new SHA2();
        sha.insert("12345!".getBytes());
        System.out.println(bytesToHexString(sha.generate()));
    }
    private static void run_AES_Test(){
        AES crypt = new AES(AES_SIZE.AES_256, AES_MODE.CTR);



        int[] key = new int[]{
                0x00010203,
                0x04050607,
                0x08090a0b,
                0x0c0d0e0f,
                0x10111213,
                0x14151617,
                0x18191a1b,
                0x1c1d1e1f
        };

        byte[] plaintext = new byte[]{
                (byte) 0x00, (byte) 0x11, (byte) 0x22, (byte) 0x33,
                (byte) 0x44, (byte) 0x55, (byte) 0x66, (byte) 0x77,
                (byte) 0x88, (byte) 0x99, (byte) 0xaa, (byte) 0xbb,
                (byte) 0xcc, (byte) 0xdd, (byte) 0xee, (byte) 0xff
        };

        String str_cleartext = "Hello my darling AES! <3. It's so wonderful to see you working as intended!";
        String str_cleartext_two = "It even works if I encrypt multiple times in a row!";

        byte[] ciphertext = crypt.encrypt(str_cleartext, key);
        byte[] ciphertext_two = crypt.encrypt(str_cleartext_two, key);

        byte[] decrypted = crypt.decrypt(ciphertext, key);

        System.out.println(new String(decrypted));
        System.out.println(new String(crypt.decrypt(ciphertext_two, key)));

    }

    private static String bytesToHexString(byte[] bytes) {
        if (bytes == null) {
            return null;
        }
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            hexString.append(String.format("%02x", b));
        }
        return hexString.toString();
    }
    private static String intArrayToHexString(int[] intArray) {
        if (intArray == null) {
            return null;
        }

        StringBuilder hexString = new StringBuilder();
        for (int i : intArray) {
            hexString.append(String.format("%02x", i & 0xFF));
        }
        return hexString.toString();
    }
    private static void ints_to_bytes(int[] in, byte[] out) {
        for (int i = 0; i < in.length; i++) {
            out[(i << 2)] = (byte) (in[i] & 0xFF);
            out[(i << 2) + 1] = (byte) ((in[i] >> 8) & 0xFF);
            out[(i << 2) + 2] = (byte) ((in[i] >> 16) & 0xFF);
            out[(i << 2) + 3] = (byte) ((in[i] >> 24) & 0xFF);
        }
    }
    private static int[] bytes_to_ints(byte[] b, int len) {
        int[] l = new int[len];

        for (int i = 0; i < l.length; i++) {
            l[i] = (b[i << 2] & 0xFF) | ((int) b[(i << 2) + 1] & 0xFF) << 8 | ((int) b[(i << 2) + 2] & 0xFF) << 16 | ((int) b[(i << 2) + 3] & 0xFF) << 24;
        }

        return l;
    }


}